package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"fmt"

	"github.com/hmans/beans/internal/bean"
	"github.com/hmans/beans/internal/beancore"
	"github.com/hmans/beans/internal/graph/model"
)

// ParentID is the resolver for the parentId field.
func (r *beanResolver) ParentID(ctx context.Context, obj *bean.Bean) (*string, error) {
	if obj.Parent == "" {
		return nil, nil
	}
	return &obj.Parent, nil
}

// BlockingIds is the resolver for the blockingIds field.
func (r *beanResolver) BlockingIds(ctx context.Context, obj *bean.Bean) ([]string, error) {
	return obj.Blocking, nil
}

// BlockedByIds is the resolver for the blockedByIds field.
func (r *beanResolver) BlockedByIds(ctx context.Context, obj *bean.Bean) ([]string, error) {
	return obj.BlockedBy, nil
}

// BlockedBy is the resolver for the blockedBy field.
func (r *beanResolver) BlockedBy(ctx context.Context, obj *bean.Bean, filter *model.BeanFilter) ([]*bean.Bean, error) {
	incoming := r.Core.FindIncomingLinks(obj.ID)
	var result []*bean.Bean
	for _, link := range incoming {
		if link.LinkType == "blocking" {
			result = append(result, link.FromBean)
		}
	}
	return ApplyFilter(result, filter, r.Core), nil
}

// Blocking is the resolver for the blocking field.
func (r *beanResolver) Blocking(ctx context.Context, obj *bean.Bean, filter *model.BeanFilter) ([]*bean.Bean, error) {
	var result []*bean.Bean
	for _, targetID := range obj.Blocking {
		// Filter out broken links
		if target, err := r.Core.Get(targetID); err == nil {
			result = append(result, target)
		}
	}
	return ApplyFilter(result, filter, r.Core), nil
}

// Parent is the resolver for the parent field.
func (r *beanResolver) Parent(ctx context.Context, obj *bean.Bean) (*bean.Bean, error) {
	if obj.Parent == "" {
		return nil, nil
	}
	// Filter out broken links
	parent, err := r.Core.Get(obj.Parent)
	if err == beancore.ErrNotFound {
		return nil, nil
	}
	return parent, err
}

// Children is the resolver for the children field.
func (r *beanResolver) Children(ctx context.Context, obj *bean.Bean, filter *model.BeanFilter) ([]*bean.Bean, error) {
	incoming := r.Core.FindIncomingLinks(obj.ID)
	var result []*bean.Bean
	for _, link := range incoming {
		if link.LinkType == "parent" {
			result = append(result, link.FromBean)
		}
	}
	return ApplyFilter(result, filter, r.Core), nil
}

// CreateBean is the resolver for the createBean field.
func (r *mutationResolver) CreateBean(ctx context.Context, input model.CreateBeanInput) (*bean.Bean, error) {
	b := &bean.Bean{
		Slug:     bean.Slugify(input.Title),
		Title:    input.Title,
		Type:     "task", // default
		Blocking: []string{},
	}

	// Optional fields with defaults documented in schema
	if input.Type != nil {
		b.Type = *input.Type
	}
	if input.Status != nil {
		b.Status = *input.Status
	}
	if input.Priority != nil {
		b.Priority = *input.Priority
	}
	if input.Body != nil {
		b.Body = *input.Body
	}
	if len(input.Tags) > 0 {
		b.Tags = input.Tags
	}

	// Handle parent (with validation)
	if input.Parent != nil && *input.Parent != "" {
		// Normalise short ID to full ID
		parentID, _ := r.Core.NormalizeID(*input.Parent)
		if err := r.Core.ValidateParent(b, parentID); err != nil {
			return nil, err
		}
		b.Parent = parentID
	}

	// Handle blocking (with validation)
	if len(input.Blocking) > 0 {
		// Normalise short IDs to full IDs
		normalizedBlocking := make([]string, len(input.Blocking))
		for i, id := range input.Blocking {
			normalizedBlocking[i], _ = r.Core.NormalizeID(id)
			// Verify target exists
			if _, err := r.Core.Get(normalizedBlocking[i]); err != nil {
				return nil, fmt.Errorf("target bean not found: %s", id)
			}
		}
		b.Blocking = normalizedBlocking
	}

	// Handle blocked_by (with cycle validation)
	if len(input.BlockedBy) > 0 {
		// Normalise short IDs to full IDs
		normalizedBlockedBy := make([]string, len(input.BlockedBy))
		for i, id := range input.BlockedBy {
			normalizedBlockedBy[i], _ = r.Core.NormalizeID(id)
			// Verify blocker exists
			if _, err := r.Core.Get(normalizedBlockedBy[i]); err != nil {
				return nil, fmt.Errorf("blocker bean not found: %s", id)
			}
		}
		// Check for cycles with blocking relationships
		// (new bean being blocked_by X means X→newBean, check if newBean→X exists via blocking)
		for _, blockerID := range normalizedBlockedBy {
			for _, blockingID := range b.Blocking {
				if blockerID == blockingID {
					return nil, fmt.Errorf("would create cycle: new bean both blocks and is blocked by %s", blockerID)
				}
			}
		}
		b.BlockedBy = normalizedBlockedBy
	}

	// Handle custom prefix - pre-generate ID if prefix is provided
	if input.Prefix != nil && *input.Prefix != "" {
		idLength := 4 // default
		if cfg := r.Core.Config(); cfg != nil && cfg.Beans.IDLength > 0 {
			idLength = cfg.Beans.IDLength
		}
		b.ID = bean.NewID(*input.Prefix, idLength)
	}

	if err := r.Core.Create(b); err != nil {
		return nil, err
	}

	return b, nil
}

// UpdateBean is the resolver for the updateBean field.
func (r *mutationResolver) UpdateBean(ctx context.Context, id string, input model.UpdateBeanInput) (*bean.Bean, error) {
	b, err := r.Core.Get(id)
	if err != nil {
		return nil, err
	}

	// Validate body and bodyMod are mutually exclusive
	if input.Body != nil && input.BodyMod != nil {
		return nil, fmt.Errorf("cannot specify both body and bodyMod")
	}

	// Update fields if provided
	if input.Title != nil {
		b.Title = *input.Title
	}
	if input.Status != nil {
		b.Status = *input.Status
	}
	if input.Type != nil {
		b.Type = *input.Type
	}
	if input.Priority != nil {
		b.Priority = *input.Priority
	}
	if input.Body != nil {
		b.Body = *input.Body
	} else if input.BodyMod != nil {
		// Apply body modifications
		workingBody := b.Body

		// Apply replacements sequentially
		if input.BodyMod.Replace != nil {
			for i, replaceOp := range input.BodyMod.Replace {
				newBody, err := bean.ReplaceOnce(workingBody, replaceOp.Old, replaceOp.New)
				if err != nil {
					return nil, fmt.Errorf("replacement %d failed: %w", i, err)
				}
				workingBody = newBody
			}
		}

		// Apply append if provided
		if input.BodyMod.Append != nil && *input.BodyMod.Append != "" {
			workingBody = bean.AppendWithSeparator(workingBody, *input.BodyMod.Append)
		}

		b.Body = workingBody
	}
	if input.Tags != nil {
		b.Tags = input.Tags
	}

	// ETag validation now happens inside Update() under write lock
	if err := r.Core.Update(b, input.IfMatch); err != nil {
		return nil, err
	}

	return b, nil
}

// DeleteBean is the resolver for the deleteBean field.
func (r *mutationResolver) DeleteBean(ctx context.Context, id string) (bool, error) {
	// Verify bean exists
	_, err := r.Core.Get(id)
	if err != nil {
		return false, err
	}

	// Remove incoming links first
	if _, err := r.Core.RemoveLinksTo(id); err != nil {
		return false, err
	}

	// Delete the bean
	if err := r.Core.Delete(id); err != nil {
		return false, err
	}

	return true, nil
}

// SetParent is the resolver for the setParent field.
func (r *mutationResolver) SetParent(ctx context.Context, id string, parentID *string, ifMatch *string) (*bean.Bean, error) {
	b, err := r.Core.Get(id)
	if err != nil {
		return nil, err
	}

	newParent := ""
	if parentID != nil {
		// Normalise short ID to full ID
		newParent, _ = r.Core.NormalizeID(*parentID)
	}

	// Validate parent type hierarchy
	if newParent != "" {
		if err := r.Core.ValidateParent(b, newParent); err != nil {
			return nil, err
		}
		// Check for cycles
		if cycle := r.Core.DetectCycle(b.ID, "parent", newParent); cycle != nil {
			return nil, fmt.Errorf("would create cycle: %v", cycle)
		}
	}

	b.Parent = newParent
	// ETag validation now happens inside Update() under write lock
	if err := r.Core.Update(b, ifMatch); err != nil {
		return nil, err
	}
	return b, nil
}

// AddBlocking is the resolver for the addBlocking field.
func (r *mutationResolver) AddBlocking(ctx context.Context, id string, targetID string, ifMatch *string) (*bean.Bean, error) {
	b, err := r.Core.Get(id)
	if err != nil {
		return nil, err
	}

	// Normalise short ID to full ID
	normalizedTargetID, _ := r.Core.NormalizeID(targetID)

	if normalizedTargetID == b.ID {
		return nil, fmt.Errorf("bean cannot block itself")
	}

	// Check target exists
	if _, err := r.Core.Get(normalizedTargetID); err != nil {
		return nil, fmt.Errorf("target bean not found: %s", targetID)
	}

	// Check for cycles in both directions:
	// 1. Check if targetId already has a path to id via blocking links
	if cycle := r.Core.DetectCycle(b.ID, "blocking", normalizedTargetID); cycle != nil {
		return nil, fmt.Errorf("would create cycle: %v", cycle)
	}
	// 2. Check if targetId already has a path to id via blocked_by links
	if cycle := r.Core.DetectCycle(normalizedTargetID, "blocked_by", b.ID); cycle != nil {
		return nil, fmt.Errorf("would create cycle: %v", cycle)
	}

	b.AddBlocking(normalizedTargetID)
	// ETag validation now happens inside Update() under write lock
	if err := r.Core.Update(b, ifMatch); err != nil {
		return nil, err
	}
	return b, nil
}

// RemoveBlocking is the resolver for the removeBlocking field.
func (r *mutationResolver) RemoveBlocking(ctx context.Context, id string, targetID string, ifMatch *string) (*bean.Bean, error) {
	b, err := r.Core.Get(id)
	if err != nil {
		return nil, err
	}

	// Normalise short ID to full ID
	normalizedTargetID, _ := r.Core.NormalizeID(targetID)

	b.RemoveBlocking(normalizedTargetID)
	// ETag validation now happens inside Update() under write lock
	if err := r.Core.Update(b, ifMatch); err != nil {
		return nil, err
	}
	return b, nil
}

// AddBlockedBy is the resolver for the addBlockedBy field.
func (r *mutationResolver) AddBlockedBy(ctx context.Context, id string, targetID string, ifMatch *string) (*bean.Bean, error) {
	b, err := r.Core.Get(id)
	if err != nil {
		return nil, err
	}

	// Normalise short ID to full ID
	normalizedTargetID, _ := r.Core.NormalizeID(targetID)

	if normalizedTargetID == b.ID {
		return nil, fmt.Errorf("bean cannot be blocked by itself")
	}

	// Check target exists
	if _, err := r.Core.Get(normalizedTargetID); err != nil {
		return nil, fmt.Errorf("blocker bean not found: %s", targetID)
	}

	// Check for cycles in both directions:
	// 1. Check if targetId already has a path to id via blocking links
	if cycle := r.Core.DetectCycle(normalizedTargetID, "blocking", b.ID); cycle != nil {
		return nil, fmt.Errorf("would create cycle: %v", cycle)
	}
	// 2. Check if id already has a path to targetId via blocked_by links
	if cycle := r.Core.DetectCycle(b.ID, "blocked_by", normalizedTargetID); cycle != nil {
		return nil, fmt.Errorf("would create cycle: %v", cycle)
	}

	b.AddBlockedBy(normalizedTargetID)
	// ETag validation now happens inside Update() under write lock
	if err := r.Core.Update(b, ifMatch); err != nil {
		return nil, err
	}
	return b, nil
}

// RemoveBlockedBy is the resolver for the removeBlockedBy field.
func (r *mutationResolver) RemoveBlockedBy(ctx context.Context, id string, targetID string, ifMatch *string) (*bean.Bean, error) {
	b, err := r.Core.Get(id)
	if err != nil {
		return nil, err
	}

	// Normalise short ID to full ID
	normalizedTargetID, _ := r.Core.NormalizeID(targetID)

	b.RemoveBlockedBy(normalizedTargetID)
	// ETag validation now happens inside Update() under write lock
	if err := r.Core.Update(b, ifMatch); err != nil {
		return nil, err
	}
	return b, nil
}

// AppendToBody is the resolver for the appendToBody field.
func (r *mutationResolver) AppendToBody(ctx context.Context, id string, content string, ifMatch *string) (*bean.Bean, error) {
	panic(fmt.Errorf("not implemented: AppendToBody - appendToBody"))
}

// SyncGitBranches is the resolver for the syncGitBranches field.
func (r *mutationResolver) SyncGitBranches(ctx context.Context) ([]*bean.Bean, error) {
	if !r.Core.IsGitFlowEnabled() {
		return nil, fmt.Errorf("git integration is not enabled")
	}

	result, err := r.Core.SyncGitBranches()
	if err != nil {
		return nil, err
	}

	// If there were errors, include them in the response
	if len(result.Errors) > 0 {
		// Return the updated beans but log warnings about errors
		for _, syncErr := range result.Errors {
			// In a real implementation, you might want to log these or return them differently
			_ = syncErr
		}
	}

	return result.Updated, nil
}

// Bean is the resolver for the bean field.
func (r *queryResolver) Bean(ctx context.Context, id string) (*bean.Bean, error) {
	b, err := r.Core.Get(id)
	if err == beancore.ErrNotFound {
		return nil, nil
	}
	return b, err
}

// Beans is the resolver for the beans field.
func (r *queryResolver) Beans(ctx context.Context, filter *model.BeanFilter) ([]*bean.Bean, error) {
	var beans []*bean.Bean

	// If search filter is provided, start with search results
	if filter != nil && filter.Search != nil && *filter.Search != "" {
		searchResults, err := r.Core.Search(*filter.Search)
		if err != nil {
			return nil, err
		}
		beans = searchResults
	} else {
		beans = r.Core.All()
	}

	return ApplyFilter(beans, filter, r.Core), nil
}

// Bean returns BeanResolver implementation.
func (r *Resolver) Bean() BeanResolver { return &beanResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type beanResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
