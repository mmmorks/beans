// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"bytes"
	"fmt"
	"io"
	"strconv"
)

// Filter options for querying beans
type BeanFilter struct {
	// Full-text search across slug, title, and body using Bleve query syntax.
	//
	// Examples:
	// - "login" - exact term match
	// - "login~" - fuzzy match (1 edit distance)
	// - "login~2" - fuzzy match (2 edit distance)
	// - "log*" - wildcard prefix
	// - "\"user login\"" - exact phrase
	// - "user AND login" - both terms required
	// - "user OR login" - either term
	// - "slug:auth" - search only slug field
	// - "title:login" - search only title field
	// - "body:auth" - search only body field
	Search *string `json:"search,omitempty"`
	// Include only beans with these statuses (OR logic)
	Status []string `json:"status,omitempty"`
	// Exclude beans with these statuses
	ExcludeStatus []string `json:"excludeStatus,omitempty"`
	// Include only beans with these types (OR logic)
	Type []string `json:"type,omitempty"`
	// Exclude beans with these types
	ExcludeType []string `json:"excludeType,omitempty"`
	// Include only beans with these priorities (OR logic)
	Priority []string `json:"priority,omitempty"`
	// Exclude beans with these priorities
	ExcludePriority []string `json:"excludePriority,omitempty"`
	// Include only beans with any of these tags (OR logic)
	Tags []string `json:"tags,omitempty"`
	// Exclude beans with any of these tags
	ExcludeTags []string `json:"excludeTags,omitempty"`
	// Include only beans that have outgoing links matching these filters (OR logic)
	HasLinks []*LinkFilter `json:"hasLinks,omitempty"`
	// Include only beans that are targets of links matching these filters (OR logic)
	LinkedAs []*LinkFilter `json:"linkedAs,omitempty"`
	// Exclude beans that have outgoing links matching these filters
	NoLinks []*LinkFilter `json:"noLinks,omitempty"`
	// Exclude beans that are targets of links matching these filters
	NoLinkedAs []*LinkFilter `json:"noLinkedAs,omitempty"`
}

// Input for creating a new bean
type CreateBeanInput struct {
	// Bean title (required)
	Title string `json:"title"`
	// Bean type (defaults to 'task')
	Type *string `json:"type,omitempty"`
	// Status (defaults to 'backlog')
	Status *string `json:"status,omitempty"`
	// Priority level (defaults to 'normal')
	Priority *string `json:"priority,omitempty"`
	// Tags for categorization
	Tags []string `json:"tags,omitempty"`
	// Markdown body content
	Body *string `json:"body,omitempty"`
}

// A link filter specifies both the link type and optionally a target bean ID.
type LinkFilter struct {
	// Link type to filter on
	Type LinkType `json:"type"`
	// Optional target bean ID - if omitted, matches any target
	Target *string `json:"target,omitempty"`
}

type Mutation struct {
}

type Query struct {
}

// Input for updating an existing bean
type UpdateBeanInput struct {
	// New title
	Title *string `json:"title,omitempty"`
	// New status
	Status *string `json:"status,omitempty"`
	// New type
	Type *string `json:"type,omitempty"`
	// New priority
	Priority *string `json:"priority,omitempty"`
	// Replace all tags (nil preserves existing)
	Tags []string `json:"tags,omitempty"`
	// New body content
	Body *string `json:"body,omitempty"`
}

// Types of links between beans.
type LinkType string

const (
	// Hierarchy: bean belongs to a milestone
	LinkTypeMilestone LinkType = "MILESTONE"
	// Hierarchy: bean belongs to an epic
	LinkTypeEpic LinkType = "EPIC"
	// Hierarchy: task/bug belongs to a feature
	LinkTypeFeature LinkType = "FEATURE"
	// Relationship: this bean blocks another
	LinkTypeBlocks LinkType = "BLOCKS"
	// Relationship: beans are related
	LinkTypeRelated LinkType = "RELATED"
)

var AllLinkType = []LinkType{
	LinkTypeMilestone,
	LinkTypeEpic,
	LinkTypeFeature,
	LinkTypeBlocks,
	LinkTypeRelated,
}

func (e LinkType) IsValid() bool {
	switch e {
	case LinkTypeMilestone, LinkTypeEpic, LinkTypeFeature, LinkTypeBlocks, LinkTypeRelated:
		return true
	}
	return false
}

func (e LinkType) String() string {
	return string(e)
}

func (e *LinkType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LinkType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LinkType", str)
	}
	return nil
}

func (e LinkType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *LinkType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e LinkType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}
